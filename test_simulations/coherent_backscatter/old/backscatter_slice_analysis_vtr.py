# -*- coding: utf-8 -*-
"""
Post-processing script for Poynting Vector Calculation using PyVista

This script processes the .vtr files generated from openEMS, calculates the Poynting vector,
and generates a log-scale image of the Poynting vector's magnitude.

Tested with:
 - Python 3.10
 - openEMS v0.0.35+
 - pyvista, numpy for VTR file handling

(c) 2023 Your Name
"""

import os
import numpy as np
import pyvista as pv
import matplotlib.pyplot as plt
import matplotlib
import tempfile

matplotlib.use('Agg')  # Use non-interactive backend suitable for headless servers


def read_vtr_file(vtr_file, field='E-Field'):
    """
    Read a .vtr (VTK Rectilinear Grid) file using PyVista and return the E-field and H-field data as numpy arrays.

    Args:
    - vtr_file: str, the file path of the VTR file.

    Returns:
    - E_field: numpy array, the E-field data.
    - H_field: numpy array, the H-field data.
    """
    # Load the .vtr file using PyVista
    grid = pv.read(vtr_file)

    # Extract the E-field and H-field arrays from the grid
    field_data = grid.point_data[field]

    # Reshape the data back into 3D arrays
    dims = grid.dimensions
    field = field_data.reshape(dims[0], dims[1], dims[2], 3, order='F')

    return field


def calculate_poynting_vector(E_field, H_field):
    """
    Calculate the Poynting vector (S = E x H) from E-field and H-field components.
    Args:
    - E_field: numpy array, E-field data.
    - H_field: numpy array, H-field data.

    Returns:
    - poynting_vector: numpy arrays Sx, Sy, Sz
    """
    # Access the components of the E-field and H-field
    Ex, Ey, Ez = E_field[0, ..., 0], E_field[0, ..., 1], E_field[0, ..., 2]
    Hx, Hy, Hz = H_field[0, ..., 0], H_field[0, ..., 1], H_field[0, ..., 2]

    # Calculate the Poynting vector components
    Sx = Ey * Hz - Ez * Hy
    Sy = Ez * Hx - Ex * Hz
    Sz = Ex * Hy - Ey * Hx

    return Sx, Sy, Sz


def plot_poynting_magnitude(sim_path, e_vtr_file, h_vtr_file, desired_direction=[-1, 0, 0], bias=0, save_fig=True):
    # Load the E-field and H-field data from VTR files
    E_field = read_vtr_file(os.path.join(sim_path, e_vtr_file), field='E-Field')
    H_field = read_vtr_file(os.path.join(sim_path, h_vtr_file), field='H-Field')

    E_field = np.array(E_field)
    H_field = np.array(H_field)

    # Calculate the Poynting vector components
    Sx, Sy, Sz = calculate_poynting_vector(E_field, H_field)

    # Calculate the magnitude of the Poynting vector
    S_magnitude = np.sqrt(Sx ** 2 + Sy ** 2 + Sz ** 2)

    # Normalize the desired direction
    desired_direction = np.array(desired_direction)
    desired_direction = desired_direction / np.linalg.norm(desired_direction)

    # Project the Poynting vector onto the desired direction using the dot product
    S_projection = Sx * desired_direction[0] + Sy * desired_direction[1] + Sz * desired_direction[2]

    # Add bias to the projection, if needed
    S_projection += bias

    # Add a small epsilon to avoid log(0)
    epsilon = 1e-12
    S_projection_log = np.log10(np.abs(S_projection) + epsilon)

    # Print the range to verify the data
    print("S_projection range:", np.min(S_projection), np.max(S_projection))

    # Set up the figure for the log-scale image
    plt.figure(figsize=(10, 8))
    plt.imshow(
        S_projection_log,  # Log scale of the projected Poynting vector magnitude
        origin='lower',  # Origin at the bottom-left
        aspect='auto',  # Aspect ratio
        cmap='jet',  # Color map
    )
    plt.colorbar(label='Projected Poynting Vector (log scale)')
    plt.title(f'Poynting Vector Projection (Log-Scale) in yz-plane along {desired_direction}')
    plt.xlabel('y-axis Index')
    plt.ylabel('z-axis Index')
    plt.grid(False)

    # Save the image
    if save_fig:
        fig_file_path = os.path.join(sim_path, f'poynting_projection_log_scale_image.png')
        plt.savefig(fig_file_path)
        print(f"Log-scale image of Poynting vector projection saved as: {fig_file_path}")
    else:
        plt.show()

    plt.close()



if __name__ == '__main__':
    # Set the simulation path and VTR filenames
    sim_path = os.path.join(tempfile.gettempdir(), 'RCS_Spheres_Simulation_Backscatter_Vis')

    # Replace these with the actual VTR filenames generated by your simulation
    e_vtr_file = 'E_dump_outside_0000000046.vtr'
    h_vtr_file = 'H_dump_outside_0000000046.vtr'

    if not os.path.exists(sim_path):
        print(f"Simulation directory not found: {sim_path}")
    else:
        plot_poynting_magnitude(sim_path, e_vtr_file, h_vtr_file)
